\documentclass[pdftex, 12pt, a4paper]{article}
\usepackage[pdftex]{graphicx}
\usepackage[utf8x]{inputenc}
\usepackage{appendix}
\usepackage{cite}
\usepackage{rotating}
\usepackage{pdflscape}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{nomencl}
\usepackage[a4paper]{geometry}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{color}

\title{Cryptography Assignment}
\author{
        Thomas A. Grainger \\
                Department of Electronics and Computer Science\\
        University of Southampton\\
}
\date{\today}

\lstset{
    basicstyle=\footnotesize,
    frame=single,
    numbers=left,
    breaklines=true,
    caption=\lstname
}

\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}{
    fontsize=\footnotesize,
    framesep=2em, % separation between frame and text
}

\begin{document}
\maketitle

\begin{abstract}
This report aims to solve a series of challenges set by D. A. Nicole and B. Halak~\cite{instructions}, aiming for both thoroughness of methodology and accuracy of solution.  The cryptographic decryption challenges demonstrate the use of Python as a useful tool to create automated cipher decryption systems.
\end{abstract}

\tableofcontents
\pagebreak
\section{Linear feedback shift register}

The problem set forth in this challenge is to decrypt a block of what appears to be a block of data encoded as hexadecimal.

The first observation about the cypher-text is that it is presented as a bitmap. After some analysis, not discussed in this report, this bitmap appears to contain no information encoded using stegonographic techniques.  The second, is that there is a pattern of high bits that repeats every 32 bits.

\subsection{Compromising LFSR encryption}
A hint with this question identifies an LFSR as the first encryption scheme, and gives away the crib of ``Ur''.  Because of this a program, shown in appendix~\ref{break-lfsr}, was created to brute force all possible LFSR sequences that result in the first characters of the plain-text being ``Ur''.

The output of this program, when run with \verb`python break_lfsr.py <the cipher-text> Ur`, is shown in appendix~\ref{break-lfsr-out}.  This output is clearly incorrect: the output is corrupt after and including the 4th character.  Because only one output it possible with this crib, and LFSR degree something is wrong with the LFSR implementation.

\subsection{Compromising a buggy LFSR encryption implementation}
An LFSR of degree 5 will repeat every 31 bits, however, referring back to the second observation of the cipher-text there is a pattern of high bits that repeats every 32 bits. This observation is clearly contradicts the hint that the second encryption stage uses an LFSR of degree 5.

A program, shown in appendix~\ref{last-byte}, was created to brute force the last byte of the repeating 32 bit key, assuming that the first 3 bytes were from a valid 31 bit LFSR key-stream.

This resulted in only one valid solution: valid as defined by a solution with only printable characters.  This mid-stage cipher-text, shown in appendix~\ref{last-byte-out}, shows signs of a mono-alphabetic substitution cypher: repeated three letter words ``pna'' and ``gur'' indicating ``and'' and ``the'', long repeated words ``Ubjrire'', and valid use of punctuation such as commas and capitol letters after full-stops. As such this remaining cipher-text was decrypted using techniques as discussed in section~\ref{mono}.  The final solution is shown in appendix~\ref{q1-solution}.

\section{Maths}

\section{Mono-alphabetic substitution}\label{mono}
In this section we describe the results.

\section{The miss-application of RC4 in WEP and WPA-TKIP}\label{conclusions}
We worked hard, and achieved very little.

\bibliographystyle{ieeetr}
\bibliography{main}
\pagebreak


\appendices
\section{Linear feedback shift register}
\subsection{Breaking LFSR}\label{break-lfsr}
\lstinputlisting[language=Python]{break_lfsr.py}
\pagebreak

\subsection{Breaking LFSR output}\label{break-lfsr-out}
\VerbatimInput{broken_lfsr.out.txt}
\pagebreak

\subsection{Brute forcing the last byte}\label{last-byte}
\lstinputlisting[language=Python]{last_byte.py}
\pagebreak

\subsection{Mid-solution}\label{last-byte-out}
\VerbatimInput{last_byte.out.txt}

\subsection{Final Solution}\label{q1-solution}
\VerbatimInput{q1_solution.out.txt}

\section{Maths}
\pagebreak

\section{Mono-alphabetic substitution}
\subsection{Hill-climbing mono-alphabetic substitution cracker}\label{break-simplesub}
\lstinputlisting[language=Python]{break_simplesub.py}

\subsection{Final Solution}\label{q3-solution}
\VerbatimInput{q3_solution.out.txt}
\pagebreak



\end{document}