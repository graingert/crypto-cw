\documentclass[pdftex, 12pt, a4paper]{article}
\usepackage[pdftex]{graphicx}
\usepackage[utf8x]{inputenc}
\usepackage{appendix}
\usepackage{cite}
\usepackage{rotating}
\usepackage{pdflscape}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{nomencl}
\usepackage[a4paper]{geometry}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{color}

\title{Cryptography Assignment}
\author{
        Thomas A. Grainger \\
                Department of Electronics and Computer Science\\
        University of Southampton\\
}
\date{\today}

\lstset{
    basicstyle=\footnotesize,
    frame=single,
    numbers=left,
    breaklines=true,
    caption=\lstname
}

\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}{
    fontsize=\footnotesize,
    framesep=2em, % separation between frame and text
}

\begin{document}
\maketitle

\begin{abstract}
This report aims to solve a series of challenges set by D. A. Nicole and B. Halak\cite{instructions}, aiming for both thoroughness of methodology and accuracy of solution.  The cryptographic decryption challenges demonstrate the use of Python as a useful tool to create automated cipher decryption systems.
\end{abstract}

\tableofcontents
\pagebreak
\section{Linear feedback shift register}

The problem set forth in this challenge is to decrypt a block of what appears to be a block of data encoded as hexadecimal.

The first observation about the cypher-text is that it is presented as a bitmap. After some analysis, not discussed in this report, this bitmap appears to contain no information encoded using stegonographic techniques.  The second, is that there is a pattern of high bits that repeats every 32 bits.

\subsection{Compromising LFSR encryption}
A hint with this question identifies an LFSR as the first encryption scheme, and gives away the crib of ``Ur''.  Because of this a program, shown in appendix~\ref{break-lfsr}, was created to brute force all possible LFSR sequences that result in the first characters of the plain-text being ``Ur''.

The output of this program, when run with \verb`python break_lfsr.py <the cipher-text> Ur`, is shown in appendix~\ref{break-lfsr-out}.  This output is clearly incorrect: the output is corrupt after and including the 4th character.

\subsection{Compromising a buggy LFSR encryption implementation}
Referring back to the second observation of the cipher-text, a repeating pattern of high bits that repeats every 32 bits. This observation is clearly at odds with an LFSR of degree 5: these LFSRs repeat every 31 bits. The observed 32bit pattern can be quantified using autocorrelation.

A program, shown in appendix~\ref{last-byte}, was created to brute force the last byte of the repeating 32 bit key, assuming that the first 3 bytes were from a valid 31 bit LFSR key-stream.

This resulted in only one valid solution, clearly a mono-alphabetic substitution cipher, this was solved using techniques as discussed in section~\ref{mono}.  The solution is shown in appendix~\ref{q1-solution}

\section{Maths}

\section{Mono-alphabetic Substitution}\label{mono}
In this section we describe the results.

\section{The miss-application of RC4 in WEP and WPA-TKIP}\label{conclusions}
We worked hard, and achieved very little.

\bibliographystyle{abbrv}
\bibliography{main}

\appendices
\section{}
\subsection{}\label{break-lfsr}
\lstinputlisting[language=Python]{break_lfsr.py}
\pagebreak
\subsection{}\label{break-lfsr-out}
\VerbatimInput{broken_lfsr_out.txt}
\pagebreak
\subsection{}\label{last-byte}
\lstinputlisting[language=Python]{last_byte.py}
\pagebreak
\subsection{}\label{q1-solution}
%\input{q1-solution}


\end{document}