\documentclass[pdftex, 12pt, a4paper]{article}
\usepackage[pdftex]{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{appendix}
\usepackage{rotating}
\usepackage{pdflscape}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{nomencl}
\usepackage[a4paper]{geometry}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage[style=ieee]{biblatex}
\usepackage{mathtools}

\bibliography{main}

\title{Cryptography Assignment}
\author{
    Thomas A. Grainger \\
    Department of Electronics and Computer Science\\
    University of Southampton\\
}
\date{\today}

\lstset{
    basicstyle=\footnotesize,
    frame=single,
    numbers=left,
    breaklines=true,
    caption=\lstname
}

\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}{
    fontsize=\footnotesize,
    framesep=2em, % separation between frame and text
}

\begin{document}
\maketitle

\begin{abstract}
This report aims to solve a series of challenges set by \textcite{instructions},
aiming for both thoroughness of methodology and accuracy of solution. The
cryptographic decryption challenges demonstrate the use of Python as a useful
tool to create automated cipher decryption systems.
\end{abstract}

\tableofcontents
\pagebreak
\section{Linear feedback shift register}

The problem set forth in this challenge is to decrypt what appears to be a block
of hexadecimal encoded data.

The first observation about the cypher-text is that it is presented as a bitmap.
After some analysis, not discussed in this report, the bitmap appears to
contain no information embedded using stegonographic techniques.  The second, is
that there is a pattern of high bits that repeat every 32 bits.

\subsection{Compromising LFSR encryption}
A hint with this question identifies an LFSR as the first encryption scheme, and
gives away the crib of ``Ur''.  Because of this a program, shown in
appendix~\ref{break-lfsr}, was created to brute force all possible LFSR
sequences that result in the first characters of the plain-text being ``Ur''.

The output of this program, when run with arguments\textless{}the
cipher-text\textgreater and ``Ur'', is shown in appendix~\ref{break-lfsr-out}.
This output is clearly incorrect: the output is corrupt after and including the
4th character.  Because only one output it possible with this crib, and LFSR
degree something is wrong with the LFSR implementation.

\subsection{Compromising a buggy LFSR encryption implementation}
An LFSR of degree 5 will repeat every 31 bits, however, referring back to the
second observation of the cipher-text there is a pattern of high bits that
repeats every 32 bits. This observation is clearly contradicts the hint that the
second encryption stage uses an LFSR of degree 5.

A program, shown in appendix~\ref{last-byte}, was created to brute force the
last byte of the repeating 32 bit key, assuming that the first 3 bytes were from
a valid 31 bit LFSR key-stream.

This resulted in only one valid solution: valid as defined by a solution with
only printable characters.  This mid-stage cipher-text, shown in
appendix~\ref{last-byte-out}, shows signs of a mono-alphabetic substitution
cypher: repeated three letter words ``pna'' and ``gur'' potentially indicating
``and'' and ``the'', long repeated words ``Ubjrire'', and valid use of
punctuation such as commas and capitol letters after full-stops. As such this
remaining cipher-text was decrypted using techniques as discussed in
section~\ref{mono}.  The final solution is shown in appendix~\ref{q1-solution}.

\section{Hamming codes and generator polynomials}
\subsection{Part a}
The properties of generator polynomials can be used to determine if a polynomial
is a generator polynomial.  A generator polynomial is also known as a primitive
polynomial and ``primitive polynomials are also irreducible
polynomials''~\cite{wolfram-primative}.  As such any polynomial that can be
factorized modulus 2 is not a generator polynomial.

\begin{description}
    \item[$f1(x) = x^6 + x^3 + x^2 + x + 1$] is reducible because $f1(x) = (x^2+x+1)(x^4+x^3+1)$.
    \item[$f2(x) = x^6 + x^5 + x^4 + x^3 + 1$] is reducible because $f2(x) = (x^2+x+1)(x^4+x+1)$.
    \item[$f3(x) = x^6 + x^5 + x$] is reducible because $f3(x) = x(x^5 + x^4 + 1)$.
    \item[$f4(x) = x^6 + x^5 +x^4 + x^2 +x + 1$] is reducible because $f4(x) = (x^2+x+1)(x+1)^4$.
    \item[$f5(x) = x^6 + x + 1$] is a generator polynomial by elimination.
\end{description}

These justifications can be tested using the two argument version of the
``hammgen'' function from GNU Octave~\cite{hammgen-octave}, also a function
available in MATLAB~\cite{hammgen-matlab}. Using this function it is possible to
determine if a polynomial is a generator polynomial of a hamming code or not:
when a non-generator polynomial is given as the function's second argument an
exception is raised.  A program to test all of the given polynomials is shown in
appendix~\ref{hammgen} concluded that $f5(x)$ is the only generator polynomial
out of the given functions.

\subsection{Part b}
Using the ``hammgen'' function from GNU Octave~\cite{hammgen-octave} a program,
shown in appendix~\ref{hammgen-hg}, was created to output the parity check,
H\label{parity-check}, and generator, G, matrices for $f5(x)$.
See appendix~\ref{h-matrix} for the H matrix and appendix~\ref{g-matrix} for the
G matrix.

\subsection{Part c}

Using the parity check matrix, H, from section~\ref{parity-check} it is possible
to determine if a message is a valid code word: ``In coding theory, a
parity-check matrix of a linear block code C is a generator matrix of the dual
code. As such, a codeword c is in C if and only if the matrix-vector product
$Hc^t = 0$''~\cite{check-matrix}.

A program, included in appendix~\ref{check-matrix} was written to determine that
the valid code words are m1 and m2.

\section{Mono-alphabetic substitution}\label{mono}
In this challenge, another decryption challenge, the requirement is to decrypt a
block of text included in appendix~\ref{q3-cyphertext}. This time there is no
hint provided.

The first clue that the cypher-text is the result of mono-alphabetic
substitution is the use of repeated words such as ``uli'' and ``blf''
potentially indicating the English three letter words ``and'' and ``the''. While
a frequency analysis would also be useful for solving these sorts of cyphers in
general, this was not used because of the success of the automated simple
substitution breaking program.

A program, included in appendix~\ref{break-simplesub}, based on work by
\textcite{stochastic-searching} was used to successfully break the cypher.
The solution is included in appendix~\ref{q3-solution}.

\section{The miss-application of RC4 in WEP and WPA-TKIP}\label{conclusions}

\subsection{Part a}
\subsubsection{What is WEP}
The WEP, or ``Wired Equivalent Privacy'', the security algorithm was released with the original 802.11 standard in 1999\cite{802.11}.  This system is designed to be be responsible for both authentication (access control), encryption (confidentiality) and data integrity in Wi-Fi networks. The name comes from the ``idea'' that it would provide the same security as a wired connection, however according to \textcite{intercepting-wifi}, ``despite employing the well-known and believed-secure RC4 cipher, WEP contains several major security flaws.''.

\subsubsection{RC4}
RC4 is a stream cipher and as such simulates a one-time-pad using a pseudo random number generator (PRNG) seeded from a key\cite{otp-faq}.

When encrypting binary data, each bit of the plain-text is XORed with a bit of the generated key-stream.

If you restart the process each time you get the same key-stream each time, as shown in \ref{eq:xor}.

\begin{subequations}
    \begin{align}
        P_1 \oplus KS = C_1,\\
        P_2 \oplus KS = C_2,\\
        C_1 \oplus C_2 = P_1 \oplus P_2\label{eq:xor}
    \end{align}
\end{subequations}

The reason this equality is a problem in cryptography is shown graphically in Figure~\ref{fig:xor}

\begin{figure}[htb]
    \centering
    \includegraphics[width=0.9\textwidth ]{img/smicash1}
    \caption{Graphical explanation of why reusing a keystream is dangerous cryptographically (source \protect\cite{stream-reuse})}
    \label{fig:xor}
\end{figure}

\subsubsection{Application of RC4 in WEP}
Because RC4 is a stream cipher a missing bit would cause a misalignment with the key-stream
Frames are expected to be lost so process is restarted each frame

To prevent key-stream reuse, a random 24-bit Initialization Vector (IV) is appended to the shared key.

\subsubsection{Application of CRC32 in WEP}
Every frame includes an Integrity Check Value (ICV)
CRC-32 hash of the plain-text is appended to the plain-text
The receiver re-computes the CRC-32 hash of the message and if it does not match the frame is dropped

\subsubsection{Flaws}

\paragraph{Small Key Space}

WEP uses a 40-bit shared key
Only 40-bits to comply with US restrictions on exporting cryptography technology
Brute-force was already practical when the protocol was designed
Protocol extended by many manufacturers using a 104-bit key (also called 128-bit)
The 104-bit keys operate in exactly the same way as 40-bit keys

Uses the RC4 encryption algorithm from RSA Data Security

\paragraph{ICV}
WEP uses CRC-32 hash for Integrity Check Value (ICV)
CRC is a poor cryptographic hash because it is a linear function of the message
Check-sum algorithms are ``unsuitable as cryptographic hash functions''
C'=C xor ( delta ,c( delta ))
C: original, C': modified, delta : changes, c( delta ): CRC-32 of delta
An attacker can flip any bit in the
cipher-text and correctly adjust the encrypted hash to avoid detection

\paragraph{Key-stream discovery}
RC4 becomes vulnerable if two messages are encrypted using the same key-stream
To protect against this, each frame has a random 24-bit Initialization Vector (IV)
The probability of an IV being repeated after 4,096 messages becomes likely due to the ``birthday paradox''
Can then determine plain text and key-stream

\paragraph{Frame Injection}
WEP has no anti-replay protection
Can re-use known IV and key-stream (gained from previous attacks) to generate unlimited valid frames
An attacker can capture frames and resend them
Denial of Service or send malicious traffic

\paragraph{Tews, Weinmann, and Psyhkin Shared Key Recovery}
Possible to recover 104-bit shared key in less than a minute
Uses the predictability of the ARP protocol: first 16 bytes known
XOR known bytes with the cypher text bytes
gets the first 128 bits of key-stream and IV
with enough packets, shared key can be determined statistically
Because no replay prevention, broadcast ARP requests to get more ARP responses

\paragraph{The Caffe Latte Attack}
Listen to a PROBE for an access point (AP)
Create fake SSID for the AP
Repeatedly challenge, and de-authenticate target client to force it to generate DHCP and ARP requests
Don't need to be near the original SSID
Just some client that has been configured to automatically connect to a WEP network
Sit in a coffee shop and listen to clients

\subsubsection{Fixes}

\paragraph{WEP2}
Extends shared key and IV to 128 bits
Still allows IV re-use
Still uses CRC-32 for ICV
Proprietary so not well used
\paragraph{WEPplus}
Proprietary enhancement to WEP by Agere Systems
Avoid ``Weak IVs'' in WEP
Only effective when used at ``both ends''
Doesn't prevent replay attacks
Interestingly Linux Kernel \textgreater 2.6.20 includes protection against weak IVs
Proprietary so not well used
\paragraph{Dynamic WEP}
Give each user a dynamically generated key
Never standardized, proprietary, so not well used
Idea carried over into 802.11i

\paragraph{WPA, WPA2-TKIP}
Just the minimum support required to buy time to develop WPA2
Can only use Temporal Key Integrity Protocol (TKIP)
TKIP still uses RC4, but with a better implementation:

Uses key mixing for shared key and IV
Prevents using the same encryption key twice
Uses a sequence counter to prevent replay attacks

\paragraph{WPA2-AES}
WPA2 allows the use of the Advanced Encryption Standard (AES) encryption as well as TKIP
AES is a block cipher, so none of the repeated key attacks apply
When used with AES, WPA2 might actually be secure, and is now the recommended wireless security default.

\subsection{Part b}
Aircrack-ng, on soton campus.

\pagebreak
\printbibliography

\pagebreak
\appendices
\section{Linear feedback shift register}
\subsection{Breaking LFSR}
\subsubsection{Program}\label{break-lfsr}
\lstinputlisting[language=Python]{break_lfsr.py}
\pagebreak

\subsubsection{Breaking LFSR output}\label{break-lfsr-out}
\VerbatimInput{broken_lfsr.out.txt}
\pagebreak

\subsection{Brute forcing the last byte}
\subsubsection{Program}\label{last-byte}
\lstinputlisting[language=Python]{last_byte.py}
\pagebreak

\subsubsection{Mid-solution}\label{last-byte-out}
\VerbatimInput{last_byte.out.txt}

\subsection{Final Solution}\label{q1-solution}
\VerbatimInput{q1_solution.out.txt}
\pagebreak

\section{Hamming codes and generator polynomials}
\subsection{Discovering valid generator polynomials}\label{hammgen}
\lstinputlisting[language=Python]{generator_pols.py}
\pagebreak

\subsection{H and G matrices}
\subsubsection{Program}\label{hammgen-hg}
\lstinputlisting[language=Python]{h_g_matrix.py}
\subsubsection{H matrix}\label{h-matrix}
\VerbatimInput{h_matrix.out.txt}
\subsubsection{G matrix}\label{g-matrix}
\VerbatimInput{g_matrix.out.txt}
\pagebreak

\subsection{Using the Check Matrix H}\label{check-matrix}
\lstinputlisting[language=Python]{code_words.py}
\pagebreak

\section{Mono-alphabetic substitution}
\subsection{Cyphertext}\label{q3-cyphertext}
\VerbatimInput{q3.out.txt}

\subsection{Hill-climbing mono-alphabetic substitution cracker}\label{break-simplesub}
\lstinputlisting[language=Python]{break_simplesub.py}
\pagebreak

\subsection{Final Solution}\label{q3-solution}
\VerbatimInput{q3_solution.out.txt}
\pagebreak


\end{document}