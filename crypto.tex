\documentclass[pdftex, 12pt, a4paper]{article}
\usepackage[pdftex]{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{appendix}
\usepackage{rotating}
\usepackage{pdflscape}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{nomencl}
\usepackage[a4paper]{geometry}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{color}
\usepackage[style=ieee]{biblatex}
\usepackage{mathtools}

\bibliography{main}

\title{Cryptography Assignment}
\author{
        Thomas A. Grainger \\
                Department of Electronics and Computer Science\\
        University of Southampton\\
}
\date{\today}

\lstset{
    basicstyle=\footnotesize,
    frame=single,
    numbers=left,
    breaklines=true,
    caption=\lstname
}

\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}{
    fontsize=\footnotesize,
    framesep=2em, % separation between frame and text
}

\begin{document}
\maketitle

\begin{abstract}
This report aims to solve a series of challenges set by D. A. Nicole and B. Halak~\cite{instructions}, aiming for both thoroughness of methodology and accuracy of solution.  The cryptographic decryption challenges demonstrate the use of Python as a useful tool to create automated cipher decryption systems.
\end{abstract}

\tableofcontents
\pagebreak
\section{Linear feedback shift register}

The problem set forth in this challenge is to decrypt a block of what appears to be a block of data encoded as hexadecimal.

The first observation about the cypher-text is that it is presented as a bitmap. After some analysis, not discussed in this report, this bitmap appears to contain no information encoded using stegonographic techniques.  The second, is that there is a pattern of high bits that repeats every 32 bits.

\subsection{Compromising LFSR encryption}
A hint with this question identifies an LFSR as the first encryption scheme, and gives away the crib of ``Ur''.  Because of this a program, shown in appendix~\ref{break-lfsr}, was created to brute force all possible LFSR sequences that result in the first characters of the plain-text being ``Ur''.

The output of this program, when run with arguments \textless{}the cipher-text\textgreater and ``Ur'', is shown in appendix~\ref{break-lfsr-out}.  This output is clearly incorrect: the output is corrupt after and including the 4th character.  Because only one output it possible with this crib, and LFSR degree something is wrong with the LFSR implementation.

\subsection{Compromising a buggy LFSR encryption implementation}
An LFSR of degree 5 will repeat every 31 bits, however, referring back to the second observation of the cipher-text there is a pattern of high bits that repeats every 32 bits. This observation is clearly contradicts the hint that the second encryption stage uses an LFSR of degree 5.

A program, shown in appendix~\ref{last-byte}, was created to brute force the last byte of the repeating 32 bit key, assuming that the first 3 bytes were from a valid 31 bit LFSR key-stream.

This resulted in only one valid solution: valid as defined by a solution with only printable characters.  This mid-stage cipher-text, shown in appendix~\ref{last-byte-out}, shows signs of a mono-alphabetic substitution cypher: repeated three letter words ``pna'' and ``gur'' potentially indicating ``and'' and ``the'', long repeated words ``Ubjrire'', and valid use of punctuation such as commas and capitol letters after full-stops. As such this remaining cipher-text was decrypted using techniques as discussed in section~\ref{mono}.  The final solution is shown in appendix~\ref{q1-solution}.

\section{Hamming codes and generator polynomials}
\subsection{Part a}
The properties of generator polynomials can be used to determine if a polynomial is a generator polynomial.  A generator polynomial is also known as a primitive polynomial and ``primitive polynomials are also irreducible polynomials''~\cite{wolfram-primative}.  As such any polynomial that can be factorized modulus 2 is not a generator polynomial.

\begin{description}
    \item[$f1(x) = x^6 + x^3 + x^2 + x + 1$] is reducible because $f1(x) = (x^2+x+1)(x^4+x^3+1)$.
    \item[$f2(x) = x^6 + x^5 + x^4 + x^3 + 1$] is reducible because $f2(x) = (x^2+x+1)(x^4+x+1)$.
    \item[$f3(x) = x^6 + x^5 + x$] is reducible because $f3(x) = x(x^5 + x^4 + 1)$.
    \item[$f4(x) = x^6 + x^5 +x^4 + x^2 +x + 1$] is reducible because $f4(x) = (x^2+x+1)(x+1)^4$.
    \item[$f5(x) = x^6 + x + 1$] is a generator polynomial by elimination.
\end{description}

These justifications can be tested using the two argument version of the ``hammgen'' function from GNU Octave~\cite{hammgen-octave}, also a function available in MATLAB~\cite{hammgen-matlab}. Using this function it is possible to determine if a polynomial is a generator polynomial of a hamming code or not: when a non-generator polynomial is given as the function's second argument an exception is raised.  A program to test all of the given polynomials is shown in appendix~\ref{hammgen} concluded that $f5(x)$ is the only generator polynomial out of the given functions.

\subsection{Part b}
Using the ``hammgen'' function from GNU Octave~\cite{hammgen-octave} a program, shown in appendix~\ref{hammgen-hg}, was created to output the parity check, H\label{parity-check}, and generator, G, matrices for $f5(x)$. See appendix~\ref{h-matrix} for the H matrix and appendix~\ref{g-matrix} for the G matrix.

\subsection{Part c}

Using the parity check matrix, H, from section~\ref{parity-check} it is possible to determine if a message is a valid code word: ``In coding theory, a parity-check matrix of a linear block code C is a generator matrix of the dual code. As such, a codeword c is in C if and only if the matrix-vector product $Hc^t = 0$''~\cite{check-matrix}.

A program, included in appendix~\ref{check-matrix} was written to determine that the valid code words are m1 and m2.

\section{Mono-alphabetic substitution}\label{mono}
In this challenge, another decryption challenge, the requirement is to decrypt a block of text included in appendix~\ref{q3-cyphertext}. This time there is no hint provided.

The first clue that the cypher-text is the result of mono-alphabetic substitution is the use of repeated words such as ``uli'' and ``blf'' potentially indicating the English three letter words ``and'' and ``the''. While a frequency analysis would also be useful for solving these sorts of cyphers in general, this was not used because of the success of the automated simple substitution breaking program.

A program, included in appendix~\ref{break-simplesub}, based on work by Lyons, J\cite{stochastic-searching} was used to successfully break the cypher. The solution is included in appendix~\ref{q3-solution}.

\section{The miss-application of RC4 in WEP and WPA-TKIP}\label{conclusions}
We worked hard, and achieved very little.

\pagebreak
\printbibliography

\pagebreak
\appendices
\section{Linear feedback shift register}
\subsection{Breaking LFSR}
\subsubsection{Program}\label{break-lfsr}
\lstinputlisting[language=Python]{break_lfsr.py}
\pagebreak

\subsubsection{Breaking LFSR output}\label{break-lfsr-out}
\VerbatimInput{broken_lfsr.out.txt}
\pagebreak

\subsection{Brute forcing the last byte}
\subsubsection{Program}\label{last-byte}
\lstinputlisting[language=Python]{last_byte.py}
\pagebreak

\subsubsection{Mid-solution}\label{last-byte-out}
\VerbatimInput{last_byte.out.txt}

\subsection{Final Solution}\label{q1-solution}
\VerbatimInput{q1_solution.out.txt}
\pagebreak

\section{Hamming codes and generator polynomials}
\subsection{Discovering valid generator polynomials}\label{hammgen}
\lstinputlisting[language=Python]{generator_pols.py}
\pagebreak

\subsection{H and G matrices}
\subsubsection{Program}\label{hammgen-hg}
\lstinputlisting[language=Python]{h_g_matrix.py}
\subsubsection{H matrix}\label{h-matrix}
\VerbatimInput{h_matrix.out.txt}
\subsubsection{G matrix}\label{g-matrix}
\VerbatimInput{g_matrix.out.txt}
\pagebreak

\subsection{Using the Check Matrix H}\label{check-matrix}
\lstinputlisting[language=Python]{code_words.py}
\pagebreak

\section{Mono-alphabetic substitution}
\subsection{Cyphertext}\label{q3-cyphertext}
\VerbatimInput{q3.out.txt}

\subsection{Hill-climbing mono-alphabetic substitution cracker}\label{break-simplesub}
\lstinputlisting[language=Python]{break_simplesub.py}
\pagebreak

\subsection{Final Solution}\label{q3-solution}
\VerbatimInput{q3_solution.out.txt}
\pagebreak


\end{document}